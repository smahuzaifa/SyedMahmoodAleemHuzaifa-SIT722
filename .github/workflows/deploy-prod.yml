name: Deploying to production

on:
  push:
    branches: [ "main" ]

permissions:
  contents: read
  id-token: write

env:
  NS: prod
  IMAGE_TAG: prod-${{ github.sha }}

jobs:
  build_and_push_prod_images:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ACR login
        run: az acr login --name ${{ secrets.ACR_NAME }}

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & push product-service
        uses: docker/build-push-action@v6
        with:
          context: ./backend/product_service
          push: true
          tags: ${{ secrets.ACR_LOGIN_SERVER }}/ecomm-product-service:${{ env.IMAGE_TAG }}

      - name: Build & push order-service
        uses: docker/build-push-action@v6
        with:
          context: ./backend/order_service
          push: true
          tags: ${{ secrets.ACR_LOGIN_SERVER }}/ecomm-order-service:${{ env.IMAGE_TAG }}

      - name: Build & push customer-service
        uses: docker/build-push-action@v6
        with:
          context: ./backend/customer_service
          push: true
          tags: ${{ secrets.ACR_LOGIN_SERVER }}/ecomm-customer-service:${{ env.IMAGE_TAG }}

      - name: Build & push frontend
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          push: true
          tags: ${{ secrets.ACR_LOGIN_SERVER }}/ecomm-frontend:${{ env.IMAGE_TAG }}

  deploy:
    runs-on: ubuntu-latest
    needs: [build_and_push_prod_images]
    environment:
      name: production

    steps:
      - uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Preflight â€“ verify AKS exists
        run: |
          az aks show -g ${{ secrets.AKS_RESOURCE_GROUP }} -n ${{ secrets.AKS_CLUSTER_NAME }} >/dev/null

      - name: Get AKS credentials
        run: az aks get-credentials -g ${{ secrets.AKS_RESOURCE_GROUP }} -n ${{ secrets.AKS_CLUSTER_NAME }} --admin --overwrite-existing

      - name: Ensure prod namespace exists + apply manifests
        run: |
          set -euo pipefail
          kubectl get ns $NS || kubectl create namespace $NS
          kubectl -n $NS apply -f k8s/secrets.yaml
          kubectl -n $NS apply -f k8s/configmaps.yaml
          kubectl -n $NS apply -f k8s/product-db.yaml
          kubectl -n $NS apply -f k8s/order-db.yaml
          kubectl -n $NS apply -f k8s/customer-db.yaml
          kubectl -n $NS apply -f k8s/rabbitmq.yaml
          kubectl -n $NS apply -f k8s/product-service.yaml
          kubectl -n $NS apply -f k8s/order-service.yaml
          kubectl -n $NS apply -f k8s/customer-service.yaml
          kubectl -n $NS apply -f k8s/frontend.yaml

      - name: Point deployments to PROD images
        env:
          REG: ${{ secrets.ACR_LOGIN_SERVER }}
        run: |
          set -euo pipefail
          kubectl -n $NS set image deployment/product-service-w08e1 product-service=$REG/ecomm-product-service:${IMAGE_TAG}
          kubectl -n $NS set image deployment/order-service-w08e1   order-service=$REG/ecomm-order-service:${IMAGE_TAG}
          kubectl -n $NS set image deployment/customer-service-w08e1 customer-service=$REG/ecomm-customer-service:${IMAGE_TAG}
          kubectl -n $NS set image deployment/frontend              frontend=$REG/ecomm-frontend:${IMAGE_TAG}

      - name: Prune bogus customer-service ReplicaSets (safety)
        run: |
          set -euo pipefail
          BAD_RS=$(kubectl -n "$NS" get rs -l app=customer-service -o jsonpath='{range .items[*]}{.metadata.name}{" "}{.spec.template.spec.containers[0].image}{"\n"}{end}' \
                   | awk '$2 ~ /REPLACE_REG|REPLACE_TAG/ {print $1}')
          if [ -n "${BAD_RS:-}" ]; then
            echo "Deleting bad ReplicaSets: $BAD_RS"
            for rs in $BAD_RS; do kubectl -n "$NS" delete rs "$rs"; done
          fi

      - name: Wait for rollout (backend + frontend) with diagnostics
        run: |
          set -euo pipefail
          wait_and_diag() {
            local deploy="$1"
            local ns="$2"
            echo "Waiting for rollout of ${deploy}..."
            if ! kubectl -n "${ns}" rollout status "deployment/${deploy}" --timeout=600s; then
              echo "---- Diagnostics for ${deploy} ----"
              kubectl -n "${ns}" get deploy/${deploy} -o wide || true
              kubectl -n "${ns}" describe deploy/${deploy} || true
              echo "ReplicaSets:"
              kubectl -n "${ns}" get rs -l app=$(kubectl -n "${ns}" get deploy/${deploy} -o jsonpath='{.spec.selector.matchLabels.app}') -o wide || true
              echo "Pods:"
              kubectl -n "${ns}" get pods -l app=$(kubectl -n "${ns}" get deploy/${deploy} -o jsonpath='{.spec.selector.matchLabels.app}') -o wide || true
              echo "Recent logs:"
              kubectl -n "${ns}" logs deploy/${deploy} --tail=200 || true
              exit 1
            fi
          }
          wait_and_diag product-service-w08e1   "$NS"
          wait_and_diag order-service-w08e1     "$NS"
          wait_and_diag customer-service-w08e1  "$NS"
          wait_and_diag frontend                "$NS"
