name: CD Pipeline - Deploy to Production

on:
  push:
    branches:
      - main   # Only trigger on production branch

jobs:
  deploy-production:
    runs-on: ubuntu-latest
    env:
      # Change if you deploy to a different namespace
      NAMESPACE: prod

    steps:
      # Checkout repo
      - name: Checkout code
        uses: actions/checkout@v3

      # Login to Azure
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # (Optional) Ensure correct subscription if your credentials span multiple subs
      # - name: Set subscription
      #   if: ${{ env.AZURE_SUBSCRIPTION_ID != '' }}
      #   run: az account set --subscription "${{ secrets.AZURE_SUBSCRIPTION_ID }}"

      # Validate that required secrets exist
      - name: Validate inputs
        env:
          AZ_RG: ${{ secrets.AZURE_RESOURCE_GROUP }}
          AZ_AKS: ${{ secrets.AZURE_AKS_CLUSTER }}
        run: |
          if [ -z "$AZ_RG" ]; then echo "❌ Missing secret: AZURE_RESOURCE_GROUP"; exit 1; fi
          if [ -z "$AZ_AKS" ]; then echo "❌ Missing secret: AZURE_AKS_CLUSTER"; exit 1; fi
          echo "✅ Resource Group: $AZ_RG"
          echo "✅ AKS Cluster: $AZ_AKS"

      # Setup kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      # Get AKS credentials
      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --name "${{ secrets.AZURE_AKS_CLUSTER }}" \
            --overwrite-existing

          # If you don't want to use secrets, hardcode instead:
          # az aks get-credentials --resource-group deakinuni --name smahweek10 --overwrite-existing

      # Ensure namespace exists and deploy manifests to it
      - name: Deploy manifests
        run: |
          # Create namespace if missing
          kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$NAMESPACE"

          # Apply all manifests into the target namespace
          # If your YAML files already specify metadata.namespace, they will use that.
          # Otherwise, this forces them into $NAMESPACE.
          kubectl apply -n "$NAMESPACE" -f k8s/

      # Wait for workloads to become Available (deployments + statefulsets)
      - name: Wait for rollouts
        run: |
          set -e

          echo "⏳ Waiting for Deployments to become Available..."
          DEPLOYS=$(kubectl -n "$NAMESPACE" get deploy -o name || true)
          if [ -n "$DEPLOYS" ]; then
            for d in $DEPLOYS; do
              echo "  -> $d"
              kubectl -n "$NAMESPACE" rollout status "$d" --timeout=300s
            done
          else
            echo "No Deployments found in $NAMESPACE"
          fi

          echo "⏳ Waiting for StatefulSets to be ready (if any)..."
          SFS=$(kubectl -n "$NAMESPACE" get statefulset -o name || true)
          if [ -n "$SFS" ]; then
            for s in $SFS; do
              echo "  -> $s"
              # Wait for all replicas to be Ready
              NAME=$(echo "$s" | cut -d'/' -f2)
              REPL=$(kubectl -n "$NAMESPACE" get "$s" -o jsonpath='{.spec.replicas}')
              kubectl -n "$NAMESPACE" rollout status "$s" --timeout=300s || true
              # Fallback readiness check
              kubectl -n "$NAMESPACE" wait --for=condition=Ready pod -l statefulset.kubernetes.io/pod-name -l app="$NAME" --timeout=300s || true
            done
          else
            echo "No StatefulSets found in $NAMESPACE"
          fi

          echo "✅ Rollouts completed."

      # Diagnostics on failure (and always print basic info)
      - name: Diagnostics (pods, events, logs)
        if: failure() || always()
        run: |
          echo "=== Pods (wide) in $NAMESPACE ==="
          kubectl -n "$NAMESPACE" get pods -o wide || true

          echo "=== Services in $NAMESPACE ==="
          kubectl -n "$NAMESPACE" get svc || true

          echo "=== Recent events (by time) in $NAMESPACE ==="
          kubectl -n "$NAMESPACE" get events --sort-by=.lastTimestamp | tail -n 200 || true

          echo "=== Describe non-ready / failing pods ==="
          # Print describe for pods not Running/Ready
          for p in $(kubectl -n "$NAMESPACE" get pods --no-headers 2>/dev/null | awk '$3!="Running" || $2 !~ /^[0-9]+\/\1$/{print $1}'); do
            echo "--- DESCRIBE $p ---"
            kubectl -n "$NAMESPACE" describe pod "$p" || true
          done

          echo "=== Logs for non-ready pods (all containers) ==="
          for p in $(kubectl -n "$NAMESPACE" get pods --no-headers 2>/dev/null | awk '$3!="Running"{print $1}'); do
            echo "--- LOGS $p ---"
            for c in $(kubectl -n "$NAMESPACE" get pod "$p" -o jsonpath='{.spec.containers[*].name}' 2>/dev/null); do
              echo ">>> container: $c (recent)"
              kubectl -n "$NAMESPACE" logs "$p" -c "$c" --tail=200 || true
              echo ">>> container: $c (previous if crashed)"
              kubectl -n "$NAMESPACE" logs "$p" -c "$c" --previous --tail=200 || true
            done
          done
